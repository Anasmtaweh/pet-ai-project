# c:\Users\Anas\M5\pet-ai-project\.github\workflows\deploy.yml
name: Backend Deployment

on:
  push:
    branches: [main] # Trigger on pushes to the main branch
    paths:
      - 'backend/**' # Only trigger if backend code changes
  workflow_dispatch: # Allow manual triggering

env:
  # Define environment variables accessible throughout the workflow
  ECR_REGISTRY: 257394484725.dkr.ecr.eu-north-1.amazonaws.com
  ECR_REPOSITORY: pet-ai-backend
  AWS_REGION: eu-north-1

jobs:
  build-deploy: # Job name
    name: Build and Deploy Backend # Display name for the job
    runs-on: ubuntu-latest
    permissions:
      contents: read # Permission to read repository content
      id-token: write # Required for aws-actions/configure-aws-credentials when using OIDC
      # packages: write # Only needed if pushing to GitHub Packages, not ECR

    steps: # List of steps for this job
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2 # Using v2
        with:
          # Using Access Keys stored as GitHub Secrets
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          # --- Alternative: OIDC ---
          # If using IAM Role for Service Accounts (OIDC), comment out keys above and uncomment below:
          # role-to-assume: arn:aws:iam::YOUR_ACCOUNT_ID:role/YOUR_OIDC_ROLE_NAME # Replace with your Role ARN
          # aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr # Step ID for potential future reference
        run: |
          echo "Attempting ECR login..."
          aws ecr get-login-password --region $AWS_REGION | \
          docker login --username AWS --password-stdin $ECR_REGISTRY
          echo "ECR login successful."

      - name: Build and push Docker image
        id: build-image # Step ID
        run: |
          IMAGE_TAG=latest # Using 'latest' tag
          echo "Building Docker image: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          # Build from the 'backend' directory relative to the repo root
          docker build --no-cache -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG ./backend
          echo "Pushing Docker image..."
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "Image pushed successfully."
          # Output the full image name if needed by subsequent steps
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      # --- Deploy to EC2 Step ---
      - name: Deploy to EC2
        uses: appleboy/ssh-action@master
        with:
          # Connection details
          host: 51.21.213.59 # Replace with your EC2 instance IP or DNS
          port: 2222 # Replace with your SSH port if not 22
          username: ec2-user # Replace with your EC2 instance username
          key: ${{ secrets.EC2_SSH_KEY }} # Private SSH key stored as a secret

          # Environment variables to pass to the script's environment on EC2
          # These MUST match the names of your GitHub Secrets EXACTLY
          envs: >
            ECR_REGISTRY,
            ECR_REPOSITORY,
            AWS_REGION,
            AWS_ACCESS_KEY_ID,
            AWS_SECRET_ACCESS_KEY,
            S3_BUCKET_NAME,
            OPENAI_API_KEY,
            DB_URL,
            EMAIL_USER,
            EMAIL_PASS,
            JWT_SECRET

          # The script to execute on the EC2 instance
          script: |
            set -e # Exit script immediately if any command fails

            echo "Checking for AWS CLI..."
            # Check if AWS CLI is installed, install if not (using yum for Amazon Linux)
            if ! command -v aws &> /dev/null; then
              echo "AWS CLI not found. Installing..."
              # Use sudo if the user (ec2-user) doesn't have root privileges by default
              sudo yum update -y && sudo yum install -y awscli
              echo "AWS CLI installed."
            fi

            echo "Exporting AWS credentials for script context..."
            # Make AWS credentials available for the ECR login command within this script
            # Note: These are already available via 'envs', but exporting ensures they are picked up by the aws cli if needed explicitly
            export AWS_ACCESS_KEY_ID="$AWS_ACCESS_KEY_ID"
            export AWS_SECRET_ACCESS_KEY="$AWS_SECRET_ACCESS_KEY"
            export AWS_REGION="$AWS_REGION"

            echo "Logging into Amazon ECR via script..."
            # Log in to ECR using the exported credentials
            aws ecr get-login-password --region $AWS_REGION | \
              docker login --username AWS --password-stdin $ECR_REGISTRY
            echo "ECR login successful via script."

            # Define image and container names using workflow env vars
            IMAGE_NAME="$ECR_REGISTRY/$ECR_REPOSITORY:latest"
            CONTAINER_NAME="backend-container"

            echo "Pulling latest image: $IMAGE_NAME"
            # Pull the newly pushed image from ECR
            docker pull $IMAGE_NAME
            echo "Image pulled successfully."

            echo "Stopping existing container if it exists: $CONTAINER_NAME"
            # Stop the currently running container, ignore error if it doesn't exist
            docker stop $CONTAINER_NAME || echo "Container '$CONTAINER_NAME' not running or failed to stop."

            echo "Removing existing container if it exists: $CONTAINER_NAME"
            # Remove the stopped container, ignore error if it doesn't exist
            docker rm $CONTAINER_NAME || echo "Container '$CONTAINER_NAME' not found or failed to remove."

            # --- START DEBUGGING ---
            echo "DEBUG: Checking JWT_SECRET value before docker run..."
            if [ -z "$JWT_SECRET" ]; then
              echo "DEBUG: ERROR - JWT_SECRET variable is EMPTY or NOT SET in the script environment!"
            else
              # Use printf for safer printing in case the secret contains special characters
              # This will print "DEBUG: JWT_SECRET variable IS SET... Value starts with: abcde..." (masked in logs)
              printf "DEBUG: JWT_SECRET variable IS SET in the script environment. Value starts with: %s\n" "${JWT_SECRET:0:5}..."
            fi
            # --- END DEBUGGING ---

            echo "Running new container: $CONTAINER_NAME"
            # Run the new container in detached mode (-d)
            # Pass ALL necessary environment variables from the script's context (via 'envs')
            # into the container using '-e' flags.
            docker run -d \
              --name $CONTAINER_NAME \
              --health-cmd="curl -sSf http://localhost:3001/health || exit 1" \
              --health-interval=30s \
              --health-retries=3 \
              --health-start-period=30s \
              --health-timeout=10s \
              --restart=unless-stopped \
              -p 3001:3001 \
              -e NODE_ENV=production \
              -e AWS_ACCESS_KEY_ID="$AWS_ACCESS_KEY_ID" \
              -e AWS_SECRET_ACCESS_KEY="$AWS_SECRET_ACCESS_KEY" \
              -e AWS_REGION="$AWS_REGION" \
              -e S3_BUCKET_NAME="$S3_BUCKET_NAME" \
              -e OPENAI_API_KEY="$OPENAI_API_KEY" \
              -e DB_URL="$DB_URL" \
              -e EMAIL_USER="$EMAIL_USER" \
              -e EMAIL_PASS="$EMAIL_PASS" \
              -e JWT_SECRET="$JWT_SECRET" \
              $IMAGE_NAME # The image to run
            echo "âœ… Deployment complete: $CONTAINER_NAME container started."

            # Optional: Clean up dangling Docker images (images without tags)
            # echo "Pruning dangling Docker images..."
            # docker image prune -f
            # echo "Image pruning complete."


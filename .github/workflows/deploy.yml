# c:\Users\Anas\M5\pet-ai-project\.github\workflows\deploy.yml
name: Backend Deployment

on:
  push:
    branches: [main] # Trigger on pushes to the main branch
    paths:
      - 'backend/**' # Only trigger if backend code changes
  workflow_dispatch: # Allow manual triggering

env:
  # Define environment variables accessible throughout the workflow
  ECR_REGISTRY: 257394484725.dkr.ecr.eu-north-1.amazonaws.com
  ECR_REPOSITORY: pet-ai-backend
  AWS_REGION: eu-north-1

jobs:
  build-deploy: # Job name
    name: Build and Deploy Backend # Display name for the job
    runs-on: ubuntu-latest
    permissions:
      contents: read # Permission to read repository content
      id-token: write # Required for aws-actions/configure-aws-credentials using OIDC

    steps: # List of steps for this job
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        run: |
          echo "Attempting ECR login..."
          # This login happens on the runner, uses runner's env vars correctly
          aws ecr get-login-password --region $AWS_REGION | \
          docker login --username AWS --password-stdin $ECR_REGISTRY
          echo "ECR login successful."

      - name: Build and push Docker image
        id: build-image
        run: |
          IMAGE_TAG=latest
          echo "Building Docker image: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          docker build --no-cache -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG ./backend
          echo "Pushing Docker image..."
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "Image pushed successfully."
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      # --- START: New Debug Step ---
      - name: Debug Secret Lengths
        run: |
          echo "--- Checking Secret Lengths ---"
          # Using printf instead of echo to avoid adding an extra newline character to the count
          # Add 1 to expected lengths below if using echo instead of printf
          printf "%s" "${{ secrets.AWS_ACCESS_KEY_ID }}" | wc -c | xargs -I {} echo "Length of AWS_ACCESS_KEY_ID: {} (Expected: 20)"
          printf "%s" "${{ secrets.AWS_SECRET_ACCESS_KEY }}" | wc -c | xargs -I {} echo "Length of AWS_SECRET_ACCESS_KEY: {} (Expected: 40)"
          printf "%s" "${{ secrets.S3_BUCKET_NAME }}" | wc -c | xargs -I {} echo "Length of S3_BUCKET_NAME: {} (Expected: length of bucket name)"
          printf "%s" "${{ secrets.OPENAI_API_KEY }}" | wc -c | xargs -I {} echo "Length of OPENAI_API_KEY: {} (Expected: 172)"
          printf "%s" "${{ secrets.DB_URL }}" | wc -c | xargs -I {} echo "Length of DB_URL: {} (Expected: length of connection string)"
          printf "%s" "${{ secrets.EMAIL_USER }}" | wc -c | xargs -I {} echo "Length of EMAIL_USER: {} (Expected: length of email)"
          printf "%s" "${{ secrets.EMAIL_PASS }}" | wc -c | xargs -I {} echo "Length of EMAIL_PASS: {} (Expected: length of password)"
          printf "%s" "${{ secrets.JWT_SECRET }}" | wc -c | xargs -I {} echo "Length of JWT_SECRET: {} (Expected: 64)"
          echo "--- Finished Checking Lengths ---"
      # --- END: New Debug Step ---

      # --- Deploy to EC2 Step ---
      - name: Deploy to EC2
        uses: appleboy/ssh-action@master
        with:
          host: 51.21.213.59
          port: 2222
          username: ec2-user
          key: ${{ secrets.EC2_SSH_KEY }}

          # Environment variables needed BY THE SCRIPT ITSELF (ECR login/pull)
          envs: >
            ECR_REGISTRY,
            ECR_REPOSITORY

          # The script to execute on the EC2 instance
          script: |
            set -e # Exit script immediately if any command fails

            # --- ECR Login and Image Pull ---
            echo "Checking for AWS CLI..."
            if ! command -v aws &> /dev/null; then
              echo "AWS CLI not found. Installing..."
              sudo yum update -y && sudo yum install -y awscli
              echo "AWS CLI installed."
            fi
            echo "Logging into Amazon ECR via script..."
            # Use direct substitution for AWS_REGION
            aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
              docker login --username AWS --password-stdin $ECR_REGISTRY # ECR_REGISTRY from envs is likely fine
            echo "ECR login successful via script."

            IMAGE_NAME="$ECR_REGISTRY/$ECR_REPOSITORY:latest"
            CONTAINER_NAME="backend-container"

            echo "Pulling latest image: $IMAGE_NAME"
            docker pull $IMAGE_NAME
            echo "Image pulled successfully."

            echo "Stopping existing container if it exists: $CONTAINER_NAME"
            docker stop $CONTAINER_NAME || echo "Container '$CONTAINER_NAME' not running or failed to stop."

            echo "Removing existing container if it exists: $CONTAINER_NAME"
            docker rm $CONTAINER_NAME || echo "Container '$CONTAINER_NAME' not found or failed to remove."
            # --- End ECR/Cleanup ---

            # --- START DEBUG: Echo the command before running ---
            echo "--- Attempting to print the docker run command (secrets masked) ---"
            # Echo the command exactly as it will be run by the shell
            # We are looking for structural errors like unexpected line breaks
            echo "docker run -d \
              --name $CONTAINER_NAME \
              --health-cmd=\"curl -sSf http://localhost:3001/health || exit 1\" \
              --health-interval=30s \
              --health-retries=3 \
              --health-start-period=30s \
              --health-timeout=10s \
              --restart=unless-stopped \
              -p 3001:3001 \
              -e NODE_ENV=production \
              -e AWS_ACCESS_KEY_ID=\"${{ secrets.AWS_ACCESS_KEY_ID }}\" \
              -e AWS_SECRET_ACCESS_KEY=\"${{ secrets.AWS_SECRET_ACCESS_KEY }}\" \
              -e AWS_REGION=\"${{ env.AWS_REGION }}\" \
              -e S3_BUCKET_NAME=\"${{ secrets.S3_BUCKET_NAME }}\" \
              -e OPENAI_API_KEY=\"${{ secrets.OPENAI_API_KEY }}\" \
              -e DB_URL=\"${{ secrets.DB_URL }}\" \
              -e EMAIL_USER=\"${{ secrets.EMAIL_USER }}\" \
              -e EMAIL_PASS=\"${{ secrets.EMAIL_PASS }}\" \
              -e JWT_SECRET=\"${{ secrets.JWT_SECRET }}\" \
              $IMAGE_NAME"
            echo "--- End of printed command ---"
            # --- END DEBUG ---

            echo "Running new container: $CONTAINER_NAME"
            # --- Actual command execution ---
            docker run -d \
              --name $CONTAINER_NAME \
              --health-cmd="curl -sSf http://localhost:3001/health || exit 1" \
              --health-interval=30s \
              --health-retries=3 \
              --health-start-period=30s \
              --health-timeout=10s \
              --restart=unless-stopped \
              -p 3001:3001 \
              -e NODE_ENV=production \
              -e AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID }}" \
              -e AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
              -e AWS_REGION="${{ env.AWS_REGION }}" \ # Use global env var
              -e S3_BUCKET_NAME="${{ secrets.S3_BUCKET_NAME }}" \
              -e OPENAI_API_KEY="${{ secrets.OPENAI_API_KEY }}" \
              -e DB_URL="${{ secrets.DB_URL }}" \
              -e EMAIL_USER="${{ secrets.EMAIL_USER }}" \
              -e EMAIL_PASS="${{ secrets.EMAIL_PASS }}" \
              -e JWT_SECRET="${{ secrets.JWT_SECRET }}" \
              $IMAGE_NAME # The image to run
            echo "âœ… Deployment complete: $CONTAINER_NAME container started."

            # Optional: Clean up dangling Docker images
            # echo "Pruning dangling Docker images..."
            # docker image prune -f
            # echo "Image pruning complete."
